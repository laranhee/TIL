## 컴파일러 이론

Javascript는 동적 또는 인터프리터 언어의 범주에 속하나 사실은 컴파일 언어다. ~~이것은 당신의 다양한 언어와의 상호 작용 수준에 따라 자명하거나 놀라울 수 있다. javascript는 많은 전통적인 컴파일 언어처럼 미리 잘 컴파일 되지 않고, 다양한 분산 시스템에서 컴파일 결과를 호환할 수 없다.~~

Javascript 엔진은 전통적인 컴파일러의 많은 단계를 일반적으로 알고 있는 것보다 더 정교한 방법으로 수행한다.

전통적인 컴파일 언어에서는 소스 코드가 실행되기 전에 일반적으로 compilation이라는 3단계를 거친다.

1. **Tokenizing/Lexing**: 문자열을 token이라는, 언어에게 의미있는 덩어리로 분해한다. `var a = 2`를 예로 들면, `var`, `a`, `=`, `2`, `;`의 토큰으로 분해 된다. 공백은 의미가 있는지 없는지에 따라 토큰이 될 수도 있고 않을 수도 있다.

 **Note**: tokenizing과 lexing의 차이는 미묘하고 학문적이지만, 토큰을 _stateless_나 _stateful_로 식별하는 것에 중점을 둔다. 만약 tokenizer가 `a`를 별개의 토큰이나 다른 토큰의 부분인지를 알아 내기 위해 stateful한 분석 규칙을 적용한다면 이는 **lexing**이다.

2. **Parsing**: 토큰의 스트림(배열)을 가져와 프로그램의 문법 구조를 집합적으로 나타내는 중첩된 요소들의 트리로 만든다. 이 트리는 "AST" (**A**bstract **S**yntax **T**ree)라 불린다.

 `var a = 2;`의 트리는 `VariableDeclaration` 최상위 노드, 값이 `a`인 `Identifier` 자식 노드, 값이 `2`인 `NumericLiteral` 자식을 가지고 있는 `AssignmentExpression` 자식 노드로 된다.

3. **Code-Generation**: AST를 가져와 실행 가능한 코드로 바꾸는 과정. 언어, 타겟 플랫폼 등에 따라 크게 다르다.

 **NOTE**: 
